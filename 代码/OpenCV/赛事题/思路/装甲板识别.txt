参考了网上的开源。
（1）预处理：
HSV空间的颜色提取 -> 二值化处理（OTSU自动寻找阈值）-> 闭运算操作
（2）条灯检测：
首先在main.cpp的while循环中对起始帧使用两个selectROI，以此来获取左右条灯的ROI。
如果没有获取起始帧的条灯，那么进行传统检测：轮廓检测 -> 长宽比筛选 -> 面积筛选 -> 与y轴夹角的角度筛选
如果获取了起始帧的条灯，那么进行CIOU匹配，寻找当前帧最优的左右条灯，在此之前先进行轮廓、长宽比、角度等的筛选，再接着进行CIOU匹配。之后进行结果更新。最后再进行判断，匹配失败，再退回传统检测。在条灯检测最后部分，进行了稳定化处理，这是为了让识别出条灯的框更稳定，而询问AI给出的代码片段。
（3）装甲板匹配及数字识别;
当检测到的条灯数量大于2再进行装甲板匹配。
暴力列举所有条灯组合进行装甲板匹配，获取所有可能的装甲板候选，再进行装甲板的两个条灯的角度差、两个条灯长度比、错位角（两条灯中心连线与x轴夹角）、宽高比的筛选，筛选出合理的装甲板，随后用加载的LeNet-5模型进行数字识别，最后，再进行错误装甲板的删除（利用AI给出一个删除函数）。
（4）PnP距离解算：
以装甲板中心为原点，以装甲板真实尺寸，设置装甲板三维图像坐标。以识别的装甲板四个顶点作为二维图像坐标，两组坐标均是左上、右上、右下、左下顶点的顺序。随后用标定相机得到的内参矩阵、畸变参数，使用solvePnp函数得到平移向量tvec，距离就是tvec[2]。