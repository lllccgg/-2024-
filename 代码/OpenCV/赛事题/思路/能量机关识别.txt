参考了网上的开源。
对于能量机关的识别：在起始帧用selectROI框选出起始帧的中心R和扇叶，作为BuffTrack类中上一帧的中心R和扇叶，有了上一帧的参考，就能使当前帧有一个更精准、稳定的识别。
（1）预处理：
利用通道相减法，B-R或者R-B，分离出蓝色或者红色，再进行二值化，形态学操作，让中心R的二值图为实心，扇叶的二值图与灯带完全连接，成为整体。
（2）寻找并筛选中心R的候选框：
寻找轮廓 -> 面积筛选 -> 长宽比筛选
（3）利用CIOU匹配找出与上一帧相似程度最高的候选框为最优的中心R
（4）寻找扇叶：
寻找轮廓 -> 面积筛选 -> 获取旋转矩阵 -> 利用旋转矩阵的长宽比进行筛选
（5）跟踪扇叶：
a.如果没有检测到待击打扇叶：令BuffTracker类的bool is_tracking为假，表示没有进行跟踪；
b.如果没有目标扇叶，但is_tracking为假，则直接选择检测的待击打扇叶中的一个作为跟踪目标，并令is_tracking为真，表示进行跟踪；
c.如果有目标扇叶，选择与上一帧目标扇叶距离最近的扇叶作为当前帧的目标扇叶，因为我们认为前后两帧的同一扇叶距离相对最小，更新目标扇叶。
（6）旋转方向判断：
由于考虑两帧之间目标扇叶的角度变化会有很大误差，所以采用收集十帧的角度差来进行旋转方向的评估，用deque<float> angle_diff_history来收集每一帧角度差，每当收集到第11帧的角度，就把最旧一帧的角度差给pop掉。扇叶的角度是相对于中心R计算得来。并且，如果是第一次记录角度差，则给angle_diff_history 加一个0.0f。在增加角度差之前，要对角度差进行解算，即angle_diff大于Π时，就减去2Π；angle_diff小于-Π，就加上2Π，这样子能够避免上一帧帧计算出-179°的角度差和下一帧计算出1°的角度差这样子的突变。解算完成，就往angle_diff_history加入一帧的角度差。只要angle_diff_history里存满10帧，就累计得到总角度差total_diff，之后进行方向判断：total_diff大于0.01f,则认为是逆时针方向；total_dif小于-0.01f,则认为是顺时针方向；否则认为未知。
（7）预测（未完成）

